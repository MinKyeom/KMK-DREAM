💯 완.전.정.확.합니다!
지금 하신 말씀이 바로 **“오버로딩과 오버라이딩의 차이”**를 정확히 짚은 거예요 👏👏👏

이걸 명확히 이해하면 자바의 다형성(polymorphism)이 완벽하게 머릿속에 정리됩니다.
이제 차근차근 이유를 설명해드릴게요.

✅ 상황 다시 정리
class Parent {
  int x, y;

  Parent(int x, int y){
    this.x = x;
    this.y = y;
  }

  int getX() {
    return x * y;
  }
}

class Child extends Parent {
  int x;

  Child(int x) {
    super(x + 1, x);
    this.x = x;
  }

  int getX(int n) {   // ⚠️ 오버라이딩이 아님 — 오버로딩!
    return super.getX() + n;
  }
}

public class Main {
  public static void main(String[] args) {
    Parent parent = new Child(10);
    System.out.println(parent.getX());
  }
}

🔹 1️⃣ 어떤 메서드가 호출될까?

👉 parent.getX() 를 보면,

참조 변수 타입은 Parent

호출하는 메서드 이름은 getX() (매개변수 없음)

자바의 메서드 호출 규칙은 다음과 같습니다 👇

✅ “메서드 시그니처(signature)”에 따라 컴파일 시점에 어떤 메서드를 부를지 결정한다.

즉,

Parent 클래스에 getX()라는 인자 없는 메서드가 있으니까 컴파일러는 그 메서드를 호출한다고 결정합니다.

Child 클래스에는 getX(int n) (매개변수가 있는 메서드)만 있으므로
→ **오버로딩(overloading)**일 뿐, **오버라이딩(overriding)**이 아닙니다.

그래서 결과적으로

parent.getX();  // ✅ Parent의 getX() 호출됨

🔹 2️⃣ 왜 Child.getX(int n)은 호출되지 않나?

이유는 간단합니다 👇

구문	의미
getX()	매개변수 없음
getX(int n)	매개변수 1개 (int)

이 두 메서드는 이름이 같지만 **서명(signature)**이 다르기 때문에,
자바는 이 둘을 전혀 다른 메서드로 인식합니다.

즉, Child.getX(int n)은 Parent.getX()를 “덮어쓴 게(override)” 아니라 “새로 추가한(override X, overload O)” 메서드입니다.

그래서 👇

호출 구문	실제 호출되는 메서드	설명
parent.getX()	Parent.getX()	오버라이딩된 버전이 없어서 부모의 것 사용
((Child) parent).getX(5)	Child.getX(int)	다운캐스팅 후에야 호출 가능
🔹 3️⃣ 만약 Child 클래스가 getX()를 “오버라이딩”했다면?
class Child extends Parent {
  int x;
  Child(int x) {
    super(x + 1, x);
    this.x = x;
  }

  @Override
  int getX() {   // 👈 오버라이딩됨
    return super.getX() + this.x;
  }
}


이제는 이렇게 동작합니다 👇

Parent parent = new Child(10);
System.out.println(parent.getX());


👉 이 경우는 다형성(polymorphism)이 적용되어
**Child의 getX()**가 호출됩니다.

✅ 최종 정리표
구분	메서드 이름	인자	관계	호출 가능 여부 (parent.getX())
Parent.getX()	getX()	없음	기본 메서드	✅ 호출됨
Child.getX(int n)	getX(int)	int 1개	오버로딩	❌ 호출 안 됨
Child.getX()	getX()	없음	오버라이딩	✅ 호출됨 (있을 경우만)
💬 비유로 정리하면

오버로딩: 같은 이름의 “다른 문”을 여는 것 (열쇠가 다름 → 매개변수 다름)

오버라이딩: 부모 문을 “교체해서” 새 문을 달아버리는 것 (매개변수 똑같음)

지금 Child는 “다른 문을 추가했을 뿐”이라,
parent.getX()로는 **새 문(Child.getX(int))**을 열 수 없는 거예요 🔒

원하신다면, getX()가 오버라이딩되는 버전과 오버로딩만 된 버전의 실제 실행 흐름을 메모리/스택 다이어그램으로도 시각화해서 보여드릴 수 있어요 —
“왜 컴파일러가 Parent의 메서드를 호출하게 되는지” 한눈에 보이게요.
그걸로 볼까요?